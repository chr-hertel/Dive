Getting started
===

Installation
---

Dive can be installed with [Composer](http://www.getcomposer.org).

Add the following requirement in your ``composer.json`` file:

```js
{
    "require": {
        "sigma-z/dive": "*"
    }
}
```

Call ``composer install`` from your command line to add ``Dive`` to your ``vendor`` folder.
If you don't know how Composer works, please check out
their [Getting Started](http://getcomposer.org/doc/00-intro.md) to set up.

Dive requires the [Symfony EventDispatcher](https://github.com/symfony/EventDispatcher).


Configure database connection
---

To work with Dive the connection details have to be defined


Import database schema
---

Dive needs to know about your database details (tables and their columns, relations and indexes, views).
See also [Section Schema](#schema).

To import the schema from an existing database you can execute a console command on the cli.

```bash
$> php ./cli/dive.php importSchema /path/to/schema.php
```

See also [Section Command importSchema](#console-dive-commands-command-importschema)


Creating record classes (Models)
---

To generate record classes as the model layer you can run
the console command [generateModels](#console-dive-commands-command-generatemodels).

```bash
$> php ./cli/dive.php generateModels /path/to/schema.php /path/to/models-dir
```

Note: You do not need to create a model class for each table. In fact, no model class will be
generated by a fresh imported schema. Define specific model classes by adding the key ``recordClass``
for tables, that should have a specific record class.

You have specific needs and want to extend from another base class instead of ``\Dive\Record``?
You can do this by added the key ``baseRecordClass`` to your schema.

See also [Section Schema](#schema).


Working with record objects
---

Querying tables
---




Schema
===

In short
---

This is a short overview of the Dive schema definition.

```php
<?php
return [
    'tables' => [
        // see table/view definition below
    ],
    'views' => [
        // see table/view definition below
    ],
    'relations' => [
        // see relation definition below 
    ],
    'baseRecordClass' => '\\Your\\Custom\\BaseRecordClass',
    'baseTableClass' => '\\Your\\Custom\\BaseTableClass'
];
```

By defining ``baseRecordClass`` every record class will extend from that class.
By defining ``baseTableClass`` every table class will extend from that class.


Table / view definition
---

This is an example for a table/view definition.


```php
<?php
return [
    'tables' => [
        'table_name' => [
            'fields' => [
                // see field definition
            ],
            'behaviors' => [],
            'validators' => []
        ],
        // and more ...
    ],
    'views' => [
        'view_name' => [
            'fields' => [
                // see field definition
            ]
        ],
        // and more ...
    ],
    // and more ...
];
```

Tables were defined by the key ``tables``, view by the key ``views``. Every entry uses its name as key in the definition.

A table/view definition must define its [fields](#schema-field-definition) with the sub-key ``fields``.

A table can define [indexes](#schema-index-definition) using the sub-key ``indexes``.

Table definitions can also define [validators](#schema-validators) and [behaviors](#schema-behaviors).

To define a special record class or table class for a table use the keys ``recordClass`` and ``tableClass``.


Field definition
---

Table and view fields are indexed by its names. 

```php
<?php
// part of table/view definition
'fields' => [
    'id_field' => [
        'primary'   => true,
        'type' => 'integer'
    ],
    // and more ...
]
```

Every field must define at least its [field types](#schema-field-types-vs-database-column-types).


Relation definition
---

A table relation is defined by the field, that owns the foreign key reference using the sub-key ``foreign``.

The sub-key ``foreign`` references to the column of referenced table. In this example the table ``article`` has a field ``author_id``
that references table ``author`` and field ``id``.

The relation details are defined in the key ``relations``. Supported relation types are ``1-m`` as One-to-Many relation,
and ``1-1`` as One-to-One relation.

``owningAlias`` is used to define a left join in a query and refers to the table that owns the foreign key column, here ``author_id``.
``refAlias`` is used to define a left join in a query to refer to the table on the other side, in this example ``author``. 

``onUpdate`` and ``onDelete`` defines constraints for update and delete operations. __Note__: These constraints are implemented as an
abstract layer - database independently - by the ORM.


```php
<?php
return [
    'tables' => [
        'author' => [
            'fields' => [
                'id' => [
                    'primary'   => true,
                    'type'      => 'integer',
                    'length'    => 10,
                    'unsigned'  => true,
                    'autoIncrement' => true
                ],
                'name' => [
                    'type'      => 'string',
                    'length'    => 64,
                    'nullable'  => true
                ]
            ]
        ],
        'article' => [
            'fields' => [
                'id'    => [
                    'primary'   => true,
                    'type'      => 'integer',
                    'length'    => 10,
                    'unsigned'  => true,
                    'autoIncrement' => true
                ],
                'author_id' => [
                    'type'      => 'integer',
                    'length'    => 10,
                    'unsigned'  => true,
                    'foreign'   => 'author.id'
                ],
                // and more fields ... 
            ]
        ]
    ],
    'relations' => [
        'article.author_id' => [
            'owningAlias' => 'Article',
            'owningField' => 'author_id',
            'owningTable' => 'article',
            'refAlias' => 'Author',
            'refField' => 'id',
            'refTable' => 'author',
            'type' => '1-m',
            'onUpdate' => 'CASCADE',
            'onDelete' => 'RESTRICT'
        ]
    ]
]
```


Field types vs database column types
---

If you importing Dive schema from an existing database Dive maps the table/view columns to their best fitting
Dive field types. By saving a record the field values will be validated by their specific types.

Read more about how database column types are mapped into dive field types
in section [Data type mapper](#data-type-mapper).

The field type is defined by the key ``type``. Here an example for a primary key definition.

```php
'id' => array(
    'type' => 'integer',
    'primary' => true,
    'autoIncrement' => true,
    'unsigned' => true
)
```

Attributes, that are applicable to most field types, are:

 - (bool)``primary`` - Default: FALSE
 - (bool)``autoIncrement`` - Default: FALSE (effective if ``primary`` is TRUE)
 - (bool)``nullable`` - Default: FALSE
 - (string)``default`` - Default value for new records


### Boolean

type: ``boolean``

### Integer

type: ``integer``

Attributes applicable:

 - (bool)``unsigned`` - Default: FALSE
 - (int)``length`` - value length
 - (bool)``zerofill`` - Flag, whether integer is zero-filled or not (Applies only to mysql databases)


### Decimal

type: ``decimal``

Attributes applicable:

 - (bool)``unsigned`` - Default: FALSE
 - (int)``length`` - value length (precision = length - 1)
 - (int)``scale`` digits after comma


### String

type: ``string``

Attributes applicable:

 - (int)``length`` - value length


### Datetime

type: ``datetime``

Datetime field type has the format: ``YYYY-MM-DD hh:mm:ss``.


### Date

type: ``date``

Date field type has the format: ``YYYY-MM-DD``.


### Time

type: ``time``

Time field type has the format: ``hh:mm:ss``.


### Blob

type: ``blob``

Binary large objects are handled as large strings.


### Enum

type: ``enum``

The enum field can be used with or without support of your database management system.
That means the Dive enum field can by a varchar in your database and Dive handles the
validation of the values set to the enum field.

Attributes applicable:

 - (array)``values`` - Accepted values


Index definition
-------

Indexes can be defined at the table definition level by the sub-key ``indexes`` using their database names as key. 

By the default there two index types: ``UNIQUE`` and ``INDEX``, defined by ``\Dive\Platform\PlatformInterface``.
MySQL (``Dive\Platform\MysqlPlatform``) defines additionally the ``FULLTEXT`` index.


```php
'indexes' => [
    'UQ_name' => [
        'type' => 'unique',
        'fields' => ['name']
    ],
    'UQ_composite' => [
        'type' => 'unique',
        'fields' => ['field1', 'field2'],
        'nullConstrained' => true
    ],
    'FK_author_id' => [
        'type' => 'index',
        'fields' => ['author_id']
    ],
    'FT_description' => [
        'type' => 'fulltext',
        'fields' => ['description']
    ],
    // and possibly more ...
],
```


### Null constrained unique constraints

__NOTE__: The unique constraint that referencing nullable fields are differently implemented in database management systems.
Check out the different [unique constraint handlings](http://troels.arvin.dk/db/rdbms/#constraints-unique) by Troels Arvin.

Dive tried to abstract the different handling for those databases that follows the standard including the ``NULL``s allowed feature.
By defining the sub-key ``nullConstrained`` with value ``true`` a unique constraint will be violated 
if an update or save would cause a data row the same characteristics in table, see overview below. 

The unique constraint for the fields ``field1`` and ``field2`` will not be violated by adding the dataset with ID: 2 if 
``nullConstrained`` is not defined (this is the default behavior) or is ``false``.

<table>
<tr>
  <td>ID</td>
  <td>field1</td>
  <td>field2</td>
</tr>
<tr>
  <td>1</td>
  <td>abc</td>
  <td>NULL</td>
</tr>
<tr>
  <td>2</td>
  <td>abc</td>
  <td>NULL</td>
</tr>
</table>



Behaviors
---------


Validators
----------


Console
=======

Common tasks, like schema imports or model generation, can be executed by the console functionality of Dive.

Prints help for usage of the Dive console:

```bash
$> php ./cli/dive.php help
```

Prints help for usage of specified command:

```bash
$> php ./cli/dive.php help <command name>
```

If you like, you can write your own commands, see [Creating custom commands](#console-creating-custom-commands)


Dive commands
---

### Command importSchema

Required params:

 - ``schema-file``:     Output file for Dive schema

Imports the schema from a database into a schema-file, built in php.

```bash
$> php ./cli/dive.php importSchema /path/to/schema.php
```

### Command generateModels

Required Params:

 - ``schema-file``:        Dive schema file (php)
 - ``target-dir``:         Target directory for model classes

Optional params:

 - ``overwrite``:          Flag to overwrite existing model classes, default if OFF
 - ``license-file``:       License text read from file will be the license comment in generated model classes
 - ``eol``:                Possible values: lf crlf cr (default is lf)
 - ``create-date-format``: Default is d.m.y

Generates record classes as the model layer.

```bash
$> php ./cli/dive.php generateModels /path/to/models-dir
```

Creating custom commands
---

Writing your own command class is easy, just

- Create a class and extend from ``\Dive\Console\Command\Command``
  (Note: the class name is the name of the command without suffix 'Command')
- Set properties ``description``, ``requiredParams`` and ``optionalParams``
- Implement ``execute()``

Sample code for custom command with name **sample**:

```php
<?php
use Dive\Console\Command\Command;

class SampleCommand extends Command
{
    public function __construct()
    {
        $this->description = 'This is a sample command';
        $this->requiredParams = array(
            'paramOne' => 'Description of required param paramOne'
        );
        $this->optionalParams = array(
            'paramTwo' => 'Description of optional param paramTwo'
        );
    }

    public function execute(OutputWriterInterface $outputWriter)
    {
        $outputWriter->writeLine('paramOne: ' . $this->getParam('paramOne'));
        $outputWriter->writeLine('paramTwo: ' . $this->getParam('paramTwo'));
        return true;
    }
}
```


Working with records
===


Validation
---


Behaviors
---


Working with queries
===


Migration
===


Data type mapper
===
